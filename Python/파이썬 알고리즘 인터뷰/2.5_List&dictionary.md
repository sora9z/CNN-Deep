# <리스트, 딕셔너리>

## 1. 리스트
- 입력순서 유지, 동적 배열로 구현됨 <br>
- 표5-1 각 언어별 동적 배열 구현 </br>
  
|언어|동적배열|
|-----|----------|
|Python|list()|
|C++|std::vector|
|Java|ArrayList|


- 스택과 큐에서 사용 가능한 모든 연산을 함께 제공한다.
- 표 5-2 리스트의 주요 연산 시간 복잡도
  |연산|시간 복잡도|설명|
  |---------------|-------|--------------------------------------------------|
  |len(a)|O(1)|전체 요소의 개수를 리턴한다|
  |a[i]|O(1)|인덱스 i의 요소를 가져온다.|
  |a[i:j]|O(k)|i부터 j까지 슬라이스의 길이만큼 k개의 요소를 가져온다.이 경우 객체 k개에 대한 조회가 필요하므로 O(k)이다.|
  |elem in a|O(n)|elem 요소가 존재하는지 확인한다. 처음부터 순서 탐색이므로 n만큼 시간이 소요된다|
  |a.count(elem)|O(n)|elem 요소의 개수를 리턴한다|
  |a.index(elem)|O(n)|elem 요소의 인덱스를 리턴한다|
  |a.appen(elem)|O(1)|리스트 마지막에 elem 요소를 추가한다|
  |a.pop()|O(1)|리스트 마지막 요소를 추출한다. 스택의 연산이다.|
  |a.pop(0)|O(n)|리스트 첫번째 요소를 추출한다. 큐의 연산이다. 이 경우 복사가 필요하므로 O(n)이다. 큐의 연산을 주로 사용한다면 리스트보다는 O(1)에 가능한 데트(deque)를 권장|
  |del a[i]|O(n)|i에 따라 다르다. 최악의 경우 O(n)이다.|
  |a.sort()|O(nlogn)|정렬한다. 팀소트(Timsort)를 사용하며, 최선의 경우 O(n)에도 실행될 수 있다.|
  |min(a), max(a)|O(n)|최솟값, 최댓값을 계산하기 위해서는 전체를 선형 탐색 해야한다.|
  |a.reverse()|O(n)|뒤집는다. 리스트는 입력 순서가 유지되므로 전체를 뒤집게 되면 입력 순서가 반대로 된다.|
  </br>

  - 리스트의 경우 탐색 시 값의 존재 유무를 확인하려면 이진 검색이 효율적이지만, 매번 정렬이 필요하고 대부분의 리스트는 정렬된 상태가 아니므로 리스트의 경우 모든 elem을 순차적으로 조회하는 형태로 구현되어 있다. 이 경우 최악의 경우 항상 O(n)이 소요된다.
  
  ### 리스트의 활용 방법

  - insert() : 특정 위치의 인덱스를 지정해 요소를 추가
    - a.insert(3,5) : 3번째 인덱스에 5를 삽입
  - 동적 배열에 삽입할 수 있는 자료형을 동일한 타입으로 제한하는 다른 언어에 비해 파이썬은 자유롭게 삽입이 가능하다(숫자,문자,볼 등)
  - Slicing 기능이 있어 특정 범위 내의 값을 매우 편리하게 조작 가능하다.
  - IndexError : 인덱스가 리스트의 길이를 넘어설 때 발생
    - 예외처리
   ```python
   try:
       print(a[9])
    except indexError:
        print("존재하지 않는 인덱스")
    ```
    - del 키워드 : 인덱스의 위치에 있는 요소 삭제
        - del a[1]
    - remove() 함수 : 값에 해당하는 요소 삭제
        - a.remove(3)
    - pop() 함수 : 스택의 pop 연산처럼 추출로 처리됨. 삭제될 값을 리턴하고 삭제가 진행된다.
        - a.pop(3)

### 리스트의 특징
- 리스트는 연속된 공간에 요소를 배치하는 배열의 장점 + 다양한 타입을 연결해 배치하는 연결 리스트의 장점을 모두 취함
- Cpython에서 리스트를 정의한 헤더
```c
typedef struct {
    PyObject_VAR_HEAD
    PyObject **ob_item;
    Py_ssize_t_allocated;
}PyListObject;
```
  - 요소에 대한 포인터 목록(ob_item)을 갖고있는 구조체
  - 리스트는 객체로 되어있는 모든 자료형을 포인터로 연결한다.
  - 객체에 대한 포인터 목록을 관리하는 형태로 구현되어 있다.</br>

- 자료형의 크기는 각각 다르기 때문에 리스트는 연속된 메모리 공간에 할당하는 것이 불가능.
- 각각의 객체에 대한 참조로 구현할 수 밖에 없다.
- 포인터의 위치를 찾아 타입 코드를 확인하는 등의 추가 작업이 필요하므로 속도면에서 불리하다.

## 2. 딕셔너리




